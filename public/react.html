<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Of Every!</title>
    <script src="https://fb.me/react-15.0.2.js"></script>
    <script src="https://fb.me/react-dom-15.0.2.js"></script>
    <!-- Bootstrap + jQuery -->
    <script   src="https://code.jquery.com/jquery-1.12.3.min.js"   integrity="sha256-aaODHAgvwQW1bFOGXMeX+pC4PZIPsvn2h1sArYOhgXQ="   crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
    	<script src="http://cdnjs.cloudflare.com/ajax/libs/react/0.12.2/JSXTransformer.js"></script>
    <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">

    <!-- Fonts -->
    <link href='https://fonts.googleapis.com/css?family=Roboto|Caveat' rel='stylesheet' type='text/css'>

    <style>
      #stage {
        border: 1px solid black;
        margin-top: 50px;
      }
      .navBtn {
        width: 100%;
        height: 100%;
        background-color: none;
        border: none;
      }
      .panel, .latCol, .panel-body {
        padding: 0;
      }
      .panel {
        min-height: 100px;
      }
      .cenCol {
        margin: 10px auto;
      }
      #container {
        text-align: center;
      }

    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="stage" width="500" height="100">
        Sorry Mate! This is only for modern browsers
      </canvas>
      <div class="container-fixed">
      <div id="configurator-app" class="panel panel-default col-md-4 col-md-offset-4">


      </div>
    </div>
  </div>

    <script type="text/javascript">
    var face_radius = 10,
        face_overlap_perc = 0.2,
        face_hair_lateral_overlap_perc = 0.3,
        face_colors = {
          LIGHT: [
                    "blanchedalmond",
                    "rgb(255,224,189)",
                    "rgb(255,205,148)"
                  ],
          DARK: [
                  "rgb(96,57,9)",
                  "rgb(62,43,19)",
                  "#894c1a",
                  "#7e4d1c",
                  "#583512"
                ]
        },
        hair_colors = {
          BLONDE: [
            "#CABFB1",
            "#DCD0BA",
            "#FFF5E1",
            "#E6CEA8",
            "#E5C8A8",
            "#DEBC99",
            "#B89778"
          ],
          BROWN: [
            "#090806",
            "#2C222B",
          ],
          GRAY: [
            "#2C222B",
            "#B7A69E",
            "#D6C4C2"
          ]
        },

        //font conf
        top_font_size = 40,
        top_font = "roboto",
        multitudes_font_size = 25,
        multitudes_font = "caveat",

        //distances
        multitudes_distance = 60,
        multitudes_text_distance = 10,
        top_font_pos_y = 40,

        //Canvas conf
        cv = document.getElementById("stage"),
        ctx = cv.getContext("2d"),
        canvas_width = 650,
        canvas_height = 300;

        //Init
        (function() {
          cv.width = canvas_width;
          cv.height = canvas_height;
        })()

        function resetCanvas(ctx) {
          //Clears all the canvas with a white rectangle
          //Used for each new group adition and update
          ctx.save();
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
          ctx.restore()
        }

        function drawHair(ctx, params) {

          var x = Number(params.x) || 0,
              y = Number(params.y) || 0,
              hair = params.hair || {color: "ALL"},
              sex = params.sex || "ALL",
              determined = params.determined || false;

              if(params.sex.toLowerCase() === "all") {
                sex = ((Math.random() > 0.5) ? "female" : "male");
              }


          //Draws hair for each face
          if(determined !== true) {
            hair = hair || {};
            if(!hair.color || hair.color.toLowerCase()=="all") {
              //Case no color setted up or setted all, the hair colors
              //will be chosen randomly from all the possible colors
              //in an equally distributed for each main color group
              var possibleHairColors = joinedCategories(hair_colors, true)
            } else {
              //Case color chosen
              var possibleHairColors = hair_colors[hair.color]
            }
            //Random from all the possibilities
            var rdm = Math.floor(Math.random()*possibleHairColors.length),
                hairColor = possibleHairColors[rdm];
          } else {
            hairColor = hair.color;
          }

          //Drawing hair
          ctx.fillStyle = hairColor;

          if(sex.toLowerCase() === "female"){
            ctx.beginPath();
              ctx.moveTo(x, y);
              //From 0 to 180 anticlockwise
              ctx.arc(x, y, face_radius, 0.2, Math.PI - 0.2, true);
              var actualX = x + face_radius*Math.cos(0.4);
              var actualY = y + face_radius*Math.cos(0.4);
              ctx.moveTo(actualX, actualY);
              ctx.lineTo(actualX, y - 10);
              //ctx.lineTo(actualX + 10 , y - 10)
              ctx.fill();
            ctx.closePath();
            ctx.beginPath();
              ctx.moveTo(x, y);
              //From 0 to 180 anticlockwise
              ctx.save();
                ctx.globalCompositeOperation = "destination-over";
                ctx.fillRect(x-face_radius, y, 2*face_radius, face_radius);
              ctx.restore();

              //ctx.lineTo(actualX + 10 , y - 10)
              ctx.fill();
            ctx.closePath();
          } else {
            ctx.beginPath();
              ctx.moveTo(x, y);
              //From 0 to 180 anticlockwise
              ctx.arc(x, y, face_radius, 0, Math.PI, true);
              var overlapXFaceHair = (1-face_hair_lateral_overlap_perc)*face_radius;
              var overlapYFaceHair = (1-2*face_hair_lateral_overlap_perc)*face_radius;
              ctx.lineTo(x-overlapXFaceHair, y);
              ctx.lineTo(x-overlapXFaceHair, y-overlapYFaceHair);
              ctx.lineTo(x+overlapXFaceHair, y-overlapYFaceHair);
              ctx.lineTo(x+overlapXFaceHair, y);
              ctx.fill();
            ctx.closePath();
          }
          return hairColor;
        }

        function repeatArr(arr, times) {
          //Returns an array formed by multiple concat of the input arr
          // arr= [a, b, c]  times= 2 -> [a, b, c, a, b, c]
          //used to create a distribution of main colors group
          var totalArr = [];
          for(var i = 0; i < times; i ++){
            totalArr = totalArr.concat(arr);
          }
          return totalArr;
        }

        function joinedCategories(category, distributed) {
          //For a person property, joins all the values for each category
          //of that property into an array deleting the differences
          //If distributed, the new array will have an equal number of
          //values for each in the final arr. That means that those categories
          //with few values, will be repeated several times till all cat have
          //same categories
          if(distributed){
            //The distributions is made by first finding a number that is
            //multiple of the lengths of the arrays for each categories.
            //The easyest way to do that is by multiplting all the lengths
            var mcm = Object.keys(category).reduce(function(tot, subcategory) {
              return tot * category[subcategory].length;
            }, 1);

            /*
            Once we have that number, we repeat the array for each category
            by the number obtained from dividing that number between the length
            of the array of this category:
                Ex: We have a property with categories cat1, cat2 and cat3
                with cat1 having 3 values, cat2 4 and cat3 5
                mcm = 60 -> cat1 is repeated 60/3 = 20 -> 20*3=60 values on
                              of cat1 are in the final arr
                            cat2 is repeated 60/4 = 15 -> 15*4=60 values on
                              the final array
                            cat3.> 60/5 = 12 -> 12*5 = 60 values of cat3 on
                              the final arr

            */
            return Object.keys(category).reduce(function(tot, subcategory) {
              return tot.concat(
                repeatArr(category[subcategory], mcm / category[subcategory].length)
              );
            }, []);

          } else {
            //In case is not distributed, return an array that is just
            //the concatenation of the arrays for each category
            return Object.keys(category).reduce(function(tot, subcategory) {
              return tot.concat(category[subcategory]);
            }, []);
          }
        }

        function drawFace(ctx, params){

          var x = Number(params.x) || 0,
              y = Number(params.y) || 0,
              hair = params.hair || {color: "ALL"},
              sex = params.sex || ((Math.random() > 0.5) ? "female" : "male"),
              determined = params.determined || false,
              skinTone = params.skinTone || "ALL";

          //Drawing an individual face on the ctx context
          //x and y point to the center of the new face
          if(determined !== true) {
            if(!skinTone || skinTone.toLowerCase()=="all") {
              var possibleFaceColors = joinedCategories(face_colors, true)
            } else {
              var possibleFaceColors = face_colors[skinTone];
            }
            //random chosing of the color face
            var rdm = Math.floor(Math.random()*possibleFaceColors.length),
                faceColor = possibleFaceColors[rdm];
          } else {
            faceColor = skinTone;
          }


          //Base Face
            ctx.save();
              ctx.fillStyle = faceColor;

              ctx.beginPath();
                //Main round
                ctx.arc(x, y, face_radius, 0, Math.PI*2, false);
              ctx.closePath();
              ctx.fill();
              //giving border
              ctx.stroke();
              //Hair
              //The source is the hair and the destination is the raund face
              //We want the hair on top the face
              ctx.globalCompositeOperation = "source-over";
              hairOptions = {
                'x': x,
                 'y': y,
                 'hair': hair,
                 'determined': determined,
                 'sex': sex
              }
              var hairColor = drawHair(ctx, hairOptions);
            ctx.restore();
            return {
                      'faceColor': faceColor,
                      'hairColor': hairColor
                    };
        }

        function drawMultitudes(ctx, options) {

          var x = Number(options.x) || 0,
              y = Number(options.y) || 0,
              num = Number(options.num) || 0,
              col = Number(options.col) || 1,
              skinTone = options.skinTone || "ALL",
              hair = options.hair || {color: "ALL"},
              group = options.group || {};
          //Draw a group of num faces organized on col number of columns
          //x and y point to the position of center of the top-left face

          //As the faces are overlaped in the vertical direction,
          //distanceY contains the distance between the center of two
          //consecutive vertival faces taking int account the overlap
          var distanceY = 2*face_radius*(1-face_overlap_perc);
          //Number of rows of the col with highest num of rows
          var maxRow = Math.ceil(num/col);
          //More like the distance between the centers of the top face and the
          //bottom face
          var height = (maxRow - 1)*distanceY;

          //Array that will save all the chars of each face for next renderings
          var facesChars = [];
          ctx.save();
            //The faces are drawed from bottom-left to top-right
            //We want that as we go down, the faces are on-top the previous
            //row. That is the reason for destination-over were destination
            //are the faces already drawed and source is the one that is going
            //to be drawn
            ctx.globalCompositeOperation = "destination-over";
            //We do this until we have finished all the faces(num == 0)
            for(var r = 0; num !== 0; r++ ) {
              //Until we reached the final column or we finished the faces
              for(var c = 0; c < col && num !== 0; c ++) {
                  //From left to right on separations of a full face
                var posx = x + face_radius*2*c,
                  //From bottom to top with ovelaped faces
                    posy = y + height - face_radius*2*r*(1-face_overlap_perc);
                    //Are faces already determined
                    var determined = group.facesChars !== undefined;
                  //draw each face
                  if(determined) {
                    var groupFace = r*col + c;
                    skinTone = group.facesChars[groupFace].faceColor;
                    hair.color = group.facesChars[groupFace].hairColor;
                  }
                  faceOptions = {
                    x: posx,
                    y: posy,
                    hair: hair,
                    sex: group.sex ||((Math.random() > 0.5) ? "female" : "male"),
                    determined: determined,
                    skinTone: skinTone
                  }
                  //console.log(faceOptions.sex, group.sex);
                  var faceChars = drawFace(ctx,
                                          faceOptions);
                  facesChars.push(faceChars);
                num--;
              }
            }
          ctx.restore();
          group.facesChars = facesChars;

        }

        /*function oneOut(ctx, num, col, x, y, skinTone) {
          var hair = {color: "BLONDE"};
          var distanceY = 2*face_radius*(1-face_overlap_perc);
          var maxRow = Math.ceil(num/col);
          var height = (maxRow - 1)*distanceY;
          var width = 2*face_radius*col;
          drawFace(ctx, x, y + height/2, skinTone, hair);
          ctx.font = "30px Arial";
          var text = ctx.measureText("out");
          ctx.fillText("out",
                       x + face_radius + (multitudes_distance - text.width)/2,
                       8 + y + height/2);
          drawMultitudes(ctx, num, col,
                          x + multitudes_distance + 2 * face_radius , y, skinTone)
          var textW = ctx.measureText(num).width;
          ctx.fillText(num,
                       x + multitudes_distance +  face_radius + (width - textW) /2 ,
                       40 + y + height);
        }*/

        function heightFromRows(n_rows) {
          //Returns height in pixels of a column of n_rows of faces
          //according to the overlapping
          var distanceY = 2*face_radius*(1-face_overlap_perc);
          return 2*face_radius + (n_rows - 1) * distanceY;
        }

        function ofEvery(ctx, params) {
          var groups = params.groups || [],
              x = params.x || 0,
              y = params.y || 0,
              defaultValues = params.defaultValues || {};

          //Important function. Incharged of drawing the situation
          //prepared by draw().

          //Options contain the default skincolor and hair color(and others)
          //for the groups in groups that don't have them specified

          //Vertical distance between the center of two consecutive
          //faces in a column
          var distanceY = 2*face_radius*(1-face_overlap_perc);
          //Starting point of the center of the most left faces in all the
          //the diagram
          var distX = x ,

              maxHeight = 0,
              totalNum = 0,
              totalRows = 0;



          groups.forEach(function(group) {
            var numRows = Math.ceil(group.num / group.col),
                heightGroup = heightFromRows(numRows);

            maxHeight = (maxHeight > heightGroup) ? maxHeight : heightGroup;
            totalNum += Number(group.num);
            totalRows += numRows;
          });


          ctx.save();
            ctx.font = top_font_size + "px " + top_font;
            var typeOfPeople = defaultValues.typeOfPeople || "people",
                cvWidth = ctx.canvas.width,
            //horizontal center of the canvas
                xCenterCv = ctx.width / 2,
                //Text of the group
                text = "Out of " + totalNum + " " + typeOfPeople,
                textWidth = ctx.measureText(text).width;
                //Pos of the text
                posXText = (cvWidth - textWidth) / 2;

          //Main text on the center of the canvas and in the top
            ctx.fillText(text , posXText, top_font_pos_y);
          ctx.restore();

          groups.map(function(group, ix) {
            var num = group.num,
                col = group.col,
                //highest num of rows for this group eleent
                maxRow = Math.ceil(num/col),
                //More like the distance between the center of the top face
                //and the bottom face
                height = (maxRow - 1)*distanceY,
                width = 2*face_radius*col,
                //Done it so all the bottom line of each multitude
                //is at the same level
                posy = y + (maxHeight - heightFromRows(maxRow))/2 ;
            //Draw group!
            multitudesOptions = {
              x: distX,
              y: posy,
              num: num,
              col: col,
              skinTone: group.skinTone || options.skinTone,
              hair: group.hair || options.hair ,
              group: group  ,
              sex: group.sex || ((Math.random() > 0.5) ? "female" : "male")
            }
            drawMultitudes(ctx, multitudesOptions);

            ctx.save()
              ctx.font = multitudes_font_size + "px " + multitudes_font;
              var xCenterMultitude = distX + width/2 - face_radius;
              //"10 are" text
              var firstText = group.num + " are";
              var numAreTextWidth = ctx.measureText(firstText).width;
              //centered with respect to the multitude graph and at a distance
              //from the bottom
              ctx.fillText(firstText,
                              xCenterMultitude - numAreTextWidth / 2,
                              y + maxHeight + multitudes_text_distance);
              //"politicians" text
              var secondText = group.name,
                  secondTextWidth = ctx.measureText(secondText).width;
              //centered with respect to the multitude graph and at a distance
              //from the bottom and the firstText
              ctx.fillText(group.name,
                              xCenterMultitude - secondTextWidth / 2,
                              y + maxHeight + 10 + multitudes_font_size);
            ctx.restore();
            //update de distX for the next multitude
            distX += multitudes_distance + width;
          });
        }

        //array that will have the info that it is going to be
        //rendered for each group
        var testgroups = [
          {
            col:3,
            hair:{color:"ALL"},
            name:"Africans",
            num: 10,
            skinTone: "DARK"
          },
          {
            col:3,
            hair:{color:"ALL"},
            name:"Africans",
            num: 10,
            skinTone: "ALL"
          }
        ];
        var groups = [];
        function draw(params, e) {
          //Main function
          params = params || {};
          if(params.number){
            //number is undefined when we just want to refresh the canvas
            //properties without adding any new group
            groups.push({
              name: params.namegroup || "People",
              num: Number(params.number) || 1,
              col: Math.floor(Math.sqrt(params.number)) || 1,
              skinTone: params.skincolor || "ALL",
              hair: {color: params.haircolor} || {color: "ALL"},
              sex: params.sex || "ALL"
            });
          }
          //Recize the canva in case of any update
          cv.width = canvas_width;
          cv.height = canvas_height;

          //Erase all the previous drawing
          resetCanvas(ctx);

          var cvw = ctx.canvas.width,
              cvh = cv.clientHeight,
              totalCols = groups.reduce(function(cols, group) {
            return cols + group.col;
          }, 0),
              numGroups = groups.length;
              totalDrawWidth = totalCols * 2 * face_radius
                              + (numGroups - 1) * multitudes_distance;
          //Posx indicates the x position of the center of the most left
          //face of the most left multitude
          var posx = (cvw - totalDrawWidth) / 2,
              maxRows = groups.reduce(function(max, group) {
                nrows = Math.ceil(group.num / group.col);
                return (max > nrows) ? max : nrows;
              }, 0),
              maxHeight = heightFromRows(maxRows);

          //Posy indicates the y position of the center of top face of the
          //the most column of the most left multitude
          var posy = (cvh - maxHeight) / 2;

          //Drawing the mulltides
          var ofEveryParams = {
            groups: groups || [],
            x: posx,
            y: posy,
            defaultValues: {
              skinTone: "ALL",
              hair:{color:"ALL"},
              sex:"ALL"
            }
          }
          ofEvery(ctx, ofEveryParams);
        }

        function updateCanva(options) {
          //Changes the main parametres of the drawing
          //and redraws it
          face_radius = Number(options.face_radius)
                                  || face_radius,
          face_overlap_perc = Number(options.face_overlap_perc)
                                    || face_overlap_perc,
          multitudes_distance = Number(options.multitudes_distance)
                                      || multitudes_distance,
          multitudes_text_distance = Number(options.multitudes_text_distance)
                                        || multitudes_text_distance,
          canvas_width = Number(options.canvas_width)
                              || canvas_width,
          canvas_height = Number(options.canvas_height)
                              || canvas_height,
          top_font_size = Number(options.top_font_size)
                                || top_font_size,
          top_font = options.top_font || top_font,
          top_font_pos_y = Number(options.top_font_pos_y)
                                  || top_font_pos_y,
          multitudes_font_size = Number(options.multitudes_font_size)
                                || multitudes_font_size,
          multitudes_font = options.multitudes_font
                                || multitudes_font;
          draw();

        }

    </script>
    <script type="text/jsx">
      class Welcome extends React.Component {
        render() {
          return (
            <div>
              Welcome To You Poll Creator!
            </div>
          );
        }
      }
      class DefineGroup extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            number: 10,
            skincolor: "ALL",
            haircolor: "ALL",
            namegroup: "Politicians",
            sex: "ALL"
          }
        }
        changeHandler(e) {
          e.preventDefault();
          var self = this;
          this.setState({
            number: self.refs.number.value,
            skincolor: self.refs.skincolor.value,
            haircolor: self.refs.haircolor.value,
            namegroup: self.refs.namegroup.value,
            sex: self.refs.sex.value
          });
        }
        drawHandler(e) {
            e.preventDefault();
            draw({
                number: this.refs.number.value,
                skincolor: this.refs.skincolor.value,
                haircolor: this.refs.haircolor.value,
                namegroup: this.refs.namegroup.value,
                sex: this.refs.sex.value
            });
        }
        erasePrevious(e){
          e.preventDefault();
          groups.pop();
          draw();
        }
        render () {
          return (
            <div>
              <button
                onClick={this.erasePrevious.bind(this)}
                className="btn btn-danger">
                  Erase Previous
              </button>
              <form>
                <label for="number">
                  Number of faces
                  <input
                        type="number"
                        ref="number"
                        value={this.state.number}
                        onChange={this.changeHandler.bind(this)}
                        placeholder="Ethiopians"
                  />
                </label>
                <br />
                <label for="namegroup">
                  Name of the group
                  <input
                        type="text"
                        ref="namegroup"
                        value={this.state.namegroup}
                        onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <br />
                <label for="sex">
                Sex
                  <select
                      name="sex"
                      ref="sex"
                      onChange={this.changeHandler.bind(this)}
                      value={this.state.sex}
                  >
                    <option value="ALL">All</option>
                    <option value="female">Female</option>
                    <option value="male">Male</option>
                  </select>
                </label>
                <br />
                <label for="SkinColor">
                Skin Color
                  <select
                      name="skincolor"
                      ref="skincolor"
                      onChange={this.changeHandler.bind(this)}
                      value={this.state.skincolor}
                  >
                    <option value="ALL">All</option>
                    <option value="LIGHT">Light</option>
                    <option value="DARK">Dark</option>
                  </select>
                </label>
                <br />
                <label for="HairColor">
                Hair Color
                  <select
                          name="haircolor"
                          ref="haircolor"
                          onChange={this.changeHandler.bind(this)}
                          value={this.state.haircolor}
                  >
                    <option value="ALL">All</option>
                    <option value="BLONDE">Blonde</option>
                    <option value="BROWN">Brown</option>
                    <option value="GRAY">Gray</option>
                  </select>
                </label>
                <br />
              <button className="btn btn-info"
                      onClick={this.drawHandler.bind(this)}>
                  Add Group!
              </button>
              </form>
            </div>
          );
        }
      }

      class DimensionsConfigurator extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            multitudesdistance: multitudes_distance,
            faceradius: face_radius,
            canvaswidth: canvas_width,
            canvasheight: canvas_height,
          }
        }
        changeHandler(e) {
          var self = this;
          var state = this.state;
          updateCanva({
            multitudes_distance: self.refs.multitudesdistance.value,
            face_radius: self.refs.faceradius.value,
            canvas_width: self.refs.canvaswidth.value,
            canvas_height: self.refs.canvasheight.value,
          });
          this.setState({
            multitudesdistance: self.refs.multitudesdistance.value,
            faceradius: self.refs.faceradius.value,
            canvaswidth: self.refs.canvaswidth.value,
            canvasheight: self.refs.canvasheight.value,
          });
        }

        render() {
          return (
            <div>
              <form>
                <label for="canvaswidth">
                  Canvas Width
                  <input
                    type="number"
                    step={5}
                    ref="canvaswidth"
                    value={this.state.canvaswidth}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <label for="canvasheight">
                  Canvas Height
                  <input
                    type="number"
                    step={5}
                    ref="canvasheight"
                    value={this.state.canvasheight}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <hr />
                <label for="faceradius">
                  Face radius<br />
                  <input
                    type="number"
                    ref="faceradius"
                    value={this.state.faceradius}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <label for="multitudesdistance">
                  Distance between groups<br />
                  <input
                    type="number"
                    ref="multitudesdistance"
                    value={this.state.multitudesdistance}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
              </form>
            </div>
          )
        }
      }
      class FontsConfigurator extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            topfont: top_font,
            topfontsize: top_font_size,
            multitudesfontsize: multitudes_font_size,
            topfontposy: top_font_pos_y
          }
        }
        changeHandler(e) {
          var self = this;
          var state = this.state;
          updateCanva({
            top_font_size:  self.refs.topfontsize.value,
            multitudes_font_size:  self.refs.multitudesfontsize.value,
            top_font: self.refs.topfont.value,
            multitudes_font: self.refs.multitudesfont.value,
            top_font_pos_y: self.refs.topfontposy.value
          });
          this.setState({
            topfontsize:  self.refs.topfontsize.value,
            topfont: self.refs.topfont.value,
            multitudesfontsize:  self.refs.multitudesfontsize.value,
            multitudesfont: self.refs.multitudesfont.value,
            topfontposy: self.refs.topfontposy.value
          });
        }

        render() {
          return (
            <div>
              <form>
                <label for="topfontsize">
                  Font size of the top text<br />
                  <input
                    type="number"
                    ref="topfontsize"
                    value={this.state.topfontsize}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <label for="topfont">
                  Font of the top text<br />
                  <select
                    ref="topfont"
                    value={this.state.topfont}
                    onChange={this.changeHandler.bind(this)}
                  >
                    <option value="roboto"> Roboto </option>
                    <option value="caveat"> Caveat </option>
                    <option value="arial"> Arial </option>
                    <option value="serif"> Serif </option>
                  </select>
                </label>
                <label for="topfontposy">
                  Vertical position of the top<br />
                  <input
                    type="number"
                    ref="topfontposy"
                    value={this.state.topfontposy}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <label for="multitudesfontsize">
                  Font size of text under each multitude<br />
                  <input
                    type="number"
                    ref="multitudesfontsize"
                    value={this.state.multitudesfontsize}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <label for="multitudesfont">
                  Font of the multitudes text<br />
                  <select
                    ref="multitudesfont"
                    value={this.state.multitudesfont}
                    onChange={this.changeHandler.bind(this)}
                  >
                    <option value="roboto"> Roboto </option>
                    <option value="caveat"> Caveat </option>
                    <option value="arial"> Arial </option>
                    <option value="serif"> Serif </option>
                  </select>
                </label>
              </form>
            </div>
          )
        }
      }
      class Page extends React.Component {
        render() {
          switch (this.props.page) {
            case "welcome":
              return (
                <Welcome />
              );
              break;
            case "definegroup":
              return (
                <DefineGroup />
              );
              break;
            case "dimensionsconfigurator":
                return (
                  <DimensionsConfigurator />
                );
                break;
            case "fontsconfigurator":
              return (
                <FontsConfigurator />
              );
              break;
            default:
              return (
                <div> Hola Hola </div>
              );
          }
        }
      }
      class Pagination extends React.Component {
        render() {
          return (
            <div className="btn-group">
              <button className="btn btn-default"
                      onClick={this.props.changeNumPage.bind(this,-1)}
              > Prev </button>
              <button className="btn btn-default"
                      onClick={this.props.changeNumPage.bind(this,1)}
              >
                 Next </button>
            </div>
          );
        }
      }
      class Configurator extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            pageNum: 1,
            page: "definegroup"
          }
          this.pageNames = ["welcome",
                            "definegroup",
                            "dimensionsconfigurator",
                            "fontsconfigurator"
                          ];
        }
        changeNumPage(variation) {
          var newPageNum = this.state.pageNum + variation,
              pageName = this.pageNames[newPageNum];
          this.setState({
            pageNum: newPageNum,
            page: pageName
          })
        }
        render() {
          return(
            <div className="panel-body container-fixed">
              <div className="latCol col-xs-2 col-md-2">
                <button className="navBtn"
                        onClick={this.changeNumPage.bind(this, -1)}
                > P </button>
              </div>
              <div className="cenCol col-xs-8 col-md-8">
                <Page page={this.state.page} />
              </div>
              <div className="latCol col-xs-2 col-md-2">
                <button className="navBtn"
                        onClick={this.changeNumPage.bind(this, 1)}
                > N </button>
              </div>
              {/*<Pagination
                  changeNumPage={this.changeNumPage.bind(this)}

              />*/}
            </div>
          );
        }
      }
      ReactDOM.render(
        <Configurator />,
      document.getElementById("configurator-app"));
    </script>
  </body>
</html>
