<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Of Every!</title>
    <script src="https://fb.me/react-15.0.2.js"></script>
    <script src="https://fb.me/react-dom-15.0.2.js"></script>
    <!-- Bootstrap + jQuery -->
    <script   src="https://code.jquery.com/jquery-1.12.3.min.js"   integrity="sha256-aaODHAgvwQW1bFOGXMeX+pC4PZIPsvn2h1sArYOhgXQ="   crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
    	<script src="http://cdnjs.cloudflare.com/ajax/libs/react/0.12.2/JSXTransformer.js"></script>
    <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.5.2/redux.js">
    </script>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js">
    </script>
    <script src="https://wzrd.in/standalone/deep-freeze@latest"></script>
    <script
      src="https://wzrd.in/standalone/expect@latest">
    </script>
    <!-- Fonts -->
    <link href='https://fonts.googleapis.com/css?family=Roboto|Caveat' rel='stylesheet' type='text/css'>

    <style>
      #stage {
        border: 1px solid black;
        margin-top: 50px;
      }
      .navBtn {
        width: 100%;
        height: 100%;
        background-color: none;
        border: none;
      }
      .panel, .latCol, .panel-body {
        padding: 0;
      }
      .panel {
        min-height: 100px;
      }
      .cenCol {
        margin: 10px auto;
      }
      #container {
        text-align: center;
      }

    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="stage" width="500" height="100">
        Sorry Mate! This is only for modern browsers
      </canvas>
      <div class="container-fixed">
      <div id="configurator-app" class="panel panel-default col-md-4 col-md-offset-4">


      </div>
    </div>
  </div>

    <script type="text/babel">
    var face_radius = 10,
        face_overlap_perc = 0.2,
        face_hair_lateral_overlap_perc = 0.3,
        face_colors = {
          LIGHT: [
                    "blanchedalmond",
                    "rgb(255,224,189)",
                    "rgb(255,205,148)"
                  ],
          DARK: [
                  "rgb(96,57,9)",
                  "rgb(62,43,19)",
                  "#894c1a",
                  "#7e4d1c",
                  "#583512"
                ]
        },
        hair_colors = {
          blonde: [
            "#CABFB1",
            "#DCD0BA",
            "#FFF5E1",
            "#E6CEA8",
            "#E5C8A8",
            "#DEBC99",
            "#B89778"
          ],
          brown: [
            "#090806",
            "#2C222B",
          ],
          gray: [
            "#2C222B",
            "#B7A69E",
            "#D6C4C2"
          ],
          red: [
            "#CD5B45",
            "#8B3E2F",
            "#FF7256"
          ]
        },
        //names
        type_people = "People",

        //font conf
        top_font_size = 40,
        top_font = "roboto",
        multitudes_font_size = 25,
        multitudes_font = "caveat",

        //distances
        multitudes_distance = 60,
        multitudes_text_distance = 10,
        top_font_pos_y = 40,

        //Canvas conf
        cv = document.getElementById("stage"),
        ctx = cv.getContext("2d"),
        canvas_width = 650,
        canvas_height = 300;

        //Init
        (function() {
          cv.width = canvas_width;
          cv.height = canvas_height;
        })()

        const resetCanvas = (ctx) => {
          //Clears all the canvas with a white rectangle
          //Used for each new group adition and update
          ctx.save();
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
          ctx.restore()
        }

        const chosenByProb = (rangeObj) => {
          //Return a key from the rangeObj randomly according
          //to the probabilityies of each:
          let arrTotProb = Object.keys(rangeObj).reduce((arr, key) => {
            let arrKeyRep = repeatArr([key], Math.floor(rangeObj[key]));
            return arr.concat(arrKeyRep)
          }, []);


          let rdm = Math.floor(Math.random()*arrTotProb.length);

          return arrTotProb[rdm];
        }

        const drawHair = (ctx, params) => {

          let x = Number(params.x) || 0,
              y = Number(params.y) || 0,
              hair = params.hair || {color: "ALL"},
              sexProbs = params.sex || "ALL",
              determined = params.determined || false,
              sex,
              hairColor,
              faceColor;

          //Select the sex of the new face
          if(typeof sexProbs === "object"){
            sex = chosenByProb(sexProbs);
          } else if(determined) {
            sex = params.sex;
          } else {
            sex = ((Math.random() > 0.5) ? "female" : "male");
          }

          //Draws hair for each face
          if(determined !== true) {
            hair = hair || {};
            let possibleHairColors;
            if(!hair.color || (hair.color.lenght === 0)){
              //Case no color setted up or setted all, the hair colors
              //will be chosen randomly from all the possible colors
              //in an equally distributed for each main color group
              possibleHairColors = joinedCategories(hair_colors, true)
            } else {
              let typeHairChosen = chosenByProb(hair.color);
              possibleHairColors = hair_colors[typeHairChosen];
            }
            //Random from all the possibilities
            let rdm = Math.floor(Math.random()*possibleHairColors.length);

            hairColor = possibleHairColors[rdm];
          } else {
            hairColor = hair.color;
          }
          //Drawing hair
          ctx.fillStyle = hairColor;

          if(sex.toLowerCase() === "female"){
            ctx.beginPath();
              ctx.moveTo(x, y);
              //From 0 to 180 anticlockwise
              ctx.arc(x, y, face_radius, 0.2, Math.PI - 0.2, true);
              let actualX = x + face_radius*Math.cos(0.4);
              let actualY = y + face_radius*Math.cos(0.4);
              ctx.moveTo(actualX, actualY);
              ctx.lineTo(actualX, y - 10);
              //ctx.lineTo(actualX + 10 , y - 10)
              ctx.fill();
            ctx.closePath();
            ctx.beginPath();
              ctx.moveTo(x, y);
              //From 0 to 180 anticlockwise
              ctx.save();
                ctx.globalCompositeOperation = "destination-over";
                ctx.fillRect(x-face_radius, y, 2*face_radius, face_radius);
              ctx.restore();

              //ctx.lineTo(actualX + 10 , y - 10)
              ctx.fill();
            ctx.closePath();
          } else {
            ctx.beginPath();
              ctx.moveTo(x, y);
              //From 0 to 180 anticlockwise
              ctx.arc(x, y, face_radius, 0, Math.PI, true);
              let overlapXFaceHair = (1-face_hair_lateral_overlap_perc)*face_radius;
              let overlapYFaceHair = (1-2*face_hair_lateral_overlap_perc)*face_radius;
              ctx.lineTo(x-overlapXFaceHair, y);
              ctx.lineTo(x-overlapXFaceHair, y-overlapYFaceHair);
              ctx.lineTo(x+overlapXFaceHair, y-overlapYFaceHair);
              ctx.lineTo(x+overlapXFaceHair, y);
              ctx.fill();
            ctx.closePath();
          }
          return {
                    hairColor: hairColor,
                    sex: sex
                  }
        }

        const repeatArr = (arr, times) => {
          //Returns an array formed by multiple concat of the input arr
          // arr= [a, b, c]  times= 2 -> [a, b, c, a, b, c]
          //used to create a distribution of main colors group
          let totalArr = [];
          for(let i = 0; i < times; i ++){
            totalArr = totalArr.concat(arr);
          }
          return totalArr;
        }

        const joinedCategories = (category, distributed) => {
          //For a person property, joins all the values for each category
          //of that property into an array deleting the differences
          //If distributed, the new array will have an equal number of
          //values for each in the final arr. That means that those categories
          //with few values, will be repeated several times till all cat have
          //same categories
          if(distributed){
            //The distributions is made by first finding a number that is
            //multiple of the lengths of the arrays for each categories.
            //The easyest way to do that is by multiplting all the lengths
            let mcm = Object.keys(category).reduce((tot, subcategory) => {
              return tot * category[subcategory].length;
            }, 1);

            /*
            Once we have that number, we repeat the array for each category
            by the number obtained from dividing that number between the length
            of the array of this category:
                Ex: We have a property with categories cat1, cat2 and cat3
                with cat1 having 3 values, cat2 4 and cat3 5
                mcm = 60 -> cat1 is repeated 60/3 = 20 -> 20*3=60 values on
                              of cat1 are in the final arr
                            cat2 is repeated 60/4 = 15 -> 15*4=60 values on
                              the final array
                            cat3.> 60/5 = 12 -> 12*5 = 60 values of cat3 on
                              the final arr

            */
            return Object.keys(category).reduce((tot, subcategory) => {
              return tot.concat(
                repeatArr(category[subcategory], mcm / category[subcategory].length)
              );
            }, []);

          } else {
            //In case is not distributed, return an array that is just
            //the concatenation of the arrays for each category
            return Object.keys(category).reduce((tot, subcategory) => {
              return tot.concat(category[subcategory]);
            }, []);
          }
        }

        const drawFace = (ctx, params) => {

          let x = Number(params.x) || 0,
              y = Number(params.y) || 0,
              hair = params.hair || {color: "ALL"},
              sex = params.sex || ((Math.random() > 0.5) ? "female" : "male"),
              determined = params.determined || false,
              skinTone;

          if(determined) {
            skinTone = params.skinTone;
          } else  if(typeof params.skinTone === "object"){
            skinTone = chosenByProb(params.skinTone).toUpperCase();
          } else{
            skinTone = "ALL";
          }

          //Drawing an individual face on the ctx context
          //x and y point to the center of the new face
          let possibleFaceColors, faceColor;
          if(determined !== true) {
            if(!skinTone || skinTone.toLowerCase()=="all") {
              possibleFaceColors = joinedCategories(face_colors, true)
            } else {
              possibleFaceColors = face_colors[skinTone];
            }
            //random chosing of the color face
            let rdm = Math.floor(Math.random()*possibleFaceColors.length);
            faceColor = possibleFaceColors[rdm];
          } else {
            faceColor = skinTone;
          }


          //Base Face
            ctx.save();
              ctx.fillStyle = faceColor;

              ctx.beginPath();
                //Main round
                ctx.arc(x, y, face_radius, 0, Math.PI*2, false);
              ctx.closePath();
              ctx.fill();
              //giving border
              ctx.stroke();
              //Hair
              //The source is the hair and the destination is the raund face
              //We want the hair on top the face
              ctx.globalCompositeOperation = "source-over";
              let hairOptions = {
                'x': x,
                 'y': y,
                 'hair': hair,
                 'determined': determined,
                 'sex': sex
              }
              let results = drawHair(ctx, hairOptions);
              console.log(results);
            ctx.restore();
            return {
                      'faceColor': faceColor,
                      'hairColor': results.hairColor,
                      'sex': results.sex
                    };
        }

        const drawMultitudes = (ctx, params) => {

          let x = Number(params.x) || 0,
              y = Number(params.y) || 0,
              num = Number(params.num) || 0,
              col = Number(params.col) || 1,
              skinTone = params.skinTone || "ALL",
              hair = params.hair || {color: "ALL"},
              group = params.group || {},
              sex = group.sex || "ALL";
          //Draw a group of num faces organized on col number of columns
          //x and y point to the position of center of the top-left face

          //As the faces are overlaped in the vertical direction,
          //distanceY contains the distance between the center of two
          //consecutive vertival faces taking int account the overlap
          let distanceY = 2*face_radius*(1-face_overlap_perc),
          //Number of rows of the col with highest num of rows
              maxRow = Math.ceil(num/col),
          //More like the distance between the centers of the top face and the
          //bottom face
              height = (maxRow - 1)*distanceY;

          //Array that will save all the chars of each face for next renderings
          let facesChars = [];
          ctx.save();
            //The faces are drawed from bottom-left to top-right
            //We want that as we go down, the faces are on-top the previous
            //row. That is the reason for destination-over were destination
            //are the faces already drawed and source is the one that is going
            //to be drawn
            ctx.globalCompositeOperation = "destination-over";
            //We do this until we have finished all the faces(num == 0)
            for(let r = 0; num !== 0; r++ ) {
              //Until we reached the final column or we finished the faces
              for(let c = 0; c < col && num !== 0; c ++) {
                  //From left to right on separations of a full face
                let posx = x + face_radius*2*c,
                  //From bottom to top with ovelaped faces
                    posy = y + height - face_radius*2*r*(1-face_overlap_perc);
                    //Are faces already determined
                    let determined = group.facesChars !== undefined;
                  //draw each face
                  if(determined) {
                    let groupFace = r*col + c;
                    skinTone = group.facesChars[groupFace].faceColor;
                    hair.color = group.facesChars[groupFace].hairColor;
                    sex = group.facesChars[groupFace].sex;
                  }
                  let faceOptions = {
                    x: posx,
                    y: posy,
                    hair: hair,
                    sex: sex,
                    determined: determined,
                    skinTone: skinTone
                  }

                  let faceChars = drawFace(ctx,
                                          faceOptions);
                  facesChars.push(faceChars);
                num--;
              }
            }
          ctx.restore();
          group.facesChars = facesChars;

        }

        /*function oneOut(ctx, num, col, x, y, skinTone) {
          let hair = {color: "blonde"};
          let distanceY = 2*face_radius*(1-face_overlap_perc);
          let maxRow = Math.ceil(num/col);
          let height = (maxRow - 1)*distanceY;
          let width = 2*face_radius*col;
          drawFace(ctx, x, y + height/2, skinTone, hair);
          ctx.font = "30px Arial";
          let text = ctx.measureText("out");
          ctx.fillText("out",
                       x + face_radius + (multitudes_distance - text.width)/2,
                       8 + y + height/2);
          drawMultitudes(ctx, num, col,
                          x + multitudes_distance + 2 * face_radius , y, skinTone)
          let textW = ctx.measureText(num).width;
          ctx.fillText(num,
                       x + multitudes_distance +  face_radius + (width - textW) /2 ,
                       40 + y + height);
        }*/

        const heightFromRows = (n_rows) => {
          //Returns height in pixels of a column of n_rows of faces
          //according to the overlapping
          let distanceY = 2*face_radius*(1-face_overlap_perc);
          return 2*face_radius + (n_rows - 1) * distanceY;
        }



        const ofEvery = (ctx, params) => {
          let groups = params.groups || [],
              x = params.x || 0,
              y = params.y || 0,
              defaultValues = params.defaultValues || {};
          if(groups.length){
            //Important function. Incharged of drawing the situation
            //prepared by draw().

            //Options contain the default skincolor and hair color(and others)
            //for the groups in groups that don't have them specified

            //Vertical distance between the center of two consecutive
            //faces in a column
            let distanceY = 2*face_radius*(1-face_overlap_perc),
            //Starting point of the center of the most left faces in all the
            //the diagram
                distX = x ,

                maxHeight = 0,
                totalNum = 0,
                totalRows = 0;



            groups.forEach(group => {
              let numRows = Math.ceil(group.num / group.col),
                  heightGroup = heightFromRows(numRows);

              maxHeight = (maxHeight > heightGroup) ? maxHeight : heightGroup;
              totalNum += Number(group.num);
              totalRows += numRows;
            });


            ctx.save();
              ctx.font = top_font_size + "px " + top_font;
              let cvWidth = ctx.canvas.width,
              //horizontal center of the canvas
                  xCenterCv = ctx.width / 2,
                  //Text of the group
                  text = "Out of " + totalNum + " " + type_people,
                  textWidth = ctx.measureText(text).width,
                  //Pos of the text
                  posXText = (cvWidth - textWidth) / 2;

            //Main text on the center of the canvas and in the top
              ctx.fillText(text , posXText, top_font_pos_y);
            ctx.restore();

            groups.map((group, ix) => {
              let num = group.num,
                  col = group.col,
                  //highest num of rows for this group eleent
                  maxRow = Math.ceil(num/col),
                  //More like the distance between the center of the top face
                  //and the bottom face
                  height = (maxRow - 1)*distanceY,
                  width = 2*face_radius*col,
                  //Done it so all the bottom line of each multitude
                  //is at the same level
                  posy = y + (maxHeight - heightFromRows(maxRow))/2 ,
              //Draw group!
              multitudesOptions = {
                x: distX,
                y: posy,
                num: num,
                col: col,
                skinTone: group.skinTone || options.skinTone,
                hair: group.hair || options.hair ,
                group: group  ,
                sex: group.sex || ((Math.random() > 0.5) ? "female" : "male")
              }

              drawMultitudes(ctx, multitudesOptions);

              ctx.save()
                ctx.font = multitudes_font_size + "px " + multitudes_font;
                let xCenterMultitude = distX + width/2 - face_radius;
                //"10 are" text
                let firstText = group.num + " are";
                let numAreTextWidth = ctx.measureText(firstText).width;
                //centered with respect to the multitude graph and at a distance
                //from the bottom
                ctx.fillText(firstText,
                                xCenterMultitude - numAreTextWidth / 2,
                                y + maxHeight + multitudes_text_distance);
                //"politicians" text
                let secondText = group.name,
                    secondTextWidth = ctx.measureText(secondText).width;
                //centered with respect to the multitude graph and at a distance
                //from the bottom and the firstText
                ctx.fillText(group.name,
                                xCenterMultitude - secondTextWidth / 2,
                                y + maxHeight + 10 + multitudes_font_size);
              ctx.restore();
              //update de distX for the next multitude
              distX += multitudes_distance + width;
            });
          }
        }

        //array that will have the info that it is going to be
        //rendered for each group

        let groups = [];

        const draw = (params, e) => {
          //Main function
          params = params || {};
          if(params.number){
            //number is undefined when we just want to refresh the canvas
            //properties without adding any new group
            groups.push({
              name: params.namegroup || "People",
              num: Number(params.number) || 1,
              col: Math.floor(Math.sqrt(params.number)) || 1,
              skinTone: params.skincolor || "ALL",
              //hair: {color: params.hairs} || {color: "ALL"},
              hair: {color: params.hairrange},
              sex: params.sex || "ALL"
            });
          }
          //Recize the canva in case of any update
          cv.width = canvas_width;
          cv.height = canvas_height;

          //Erase all the previous drawing
          resetCanvas(ctx);

          let cvw = ctx.canvas.width,
              cvh = cv.clientHeight,
              totalCols = groups.reduce((cols, group) => {
                return cols + group.col;
              }, 0),
              numGroups = groups.length,
              totalDrawWidth = totalCols * 2 * face_radius
                              + (numGroups - 1) * multitudes_distance;
          //Posx indicates the x position of the center of the most left
          //face of the most left multitude
          let posx = (cvw - totalDrawWidth) / 2,
              maxRows = groups.reduce((max, group) => {
                let nrows = Math.ceil(group.num / group.col);
                return (max > nrows) ? max : nrows;
              }, 0),
              maxHeight = heightFromRows(maxRows);

          //Posy indicates the y position of the center of top face of the
          //the most column of the most left multitude
          let posy = (cvh - maxHeight) / 2;

          //Drawing the mulltides
          let ofEveryParams = {
            groups: groups || [],
            x: posx,
            y: posy,
            defaultValues: {
              skinTone: "ALL",
              hair:{color:"ALL"},
              sex:"ALL"
            }
          }
          ofEvery(ctx, ofEveryParams);
        }

        const updateCanva = (options) => {
          //Changes the main parametres of the drawing
          //and redraws it
          type_people = options.type_people
                              || type_people,
          face_radius = Number(options.face_radius)
                                  || face_radius,
          face_overlap_perc = Number(options.face_overlap_perc)
                                    || face_overlap_perc,
          multitudes_distance = Number(options.multitudes_distance)
                                      || multitudes_distance,
          multitudes_text_distance = Number(options.multitudes_text_distance)
                                        || multitudes_text_distance,
          canvas_width = Number(options.canvas_width)
                              || canvas_width,
          canvas_height = Number(options.canvas_height)
                              || canvas_height,
          top_font_size = Number(options.top_font_size)
                                || top_font_size,
          top_font = options.top_font || top_font,
          top_font_pos_y = Number(options.top_font_pos_y)
                                  || top_font_pos_y,
          multitudes_font_size = Number(options.multitudes_font_size)
                                || multitudes_font_size,
          multitudes_font = options.multitudes_font
                                || multitudes_font;
          draw();

        }

        let testgroups = [
          {
            col:3,
            hair:{color:"ALL"},
            name:"Africans",
            num: 10,
            skinTone: "DARK"
          },
          {
            col:3,
            hair:{color:"ALL"},
            name:"Africans",
            num: 10,
            skinTone: "ALL"
          }
        ];
        const testRepeatArr = () => {
          let arrBefore = ["a"],
              arrAfter = ["a", "a", "a"];
          //Makes them immutable.
          deepFreeze(arrBefore);
          deepFreeze(arrAfter);
          console.log(  expect(repeatArr(arrBefore, 3)));
          //test
          expect(repeatArr(arrBefore, 3)).toEqual(arrAfter);
          expect(repeatArr([],3)).toEqual([]);

        }

        const testJoinedCategories = () => {
          let catBefore = {
                p1 : ["a", "b", "c"],
                p2 : ["d", "e"],
                p3 : ["f"]
              },
              catAfter = ["a", "b", "c", "d", "e", "f"],
              catAfterDist = [
                                "a", "b", "c", "a", "b", "c",
                                "d", "e", "d", "e", "d", "e",
                                "f", "f", "f", "f", "f", "f"
                            ];
          deepFreeze(catBefore);
          deepFreeze(catAfter);
          deepFreeze(catAfterDist);

          expect(joinedCategories(catBefore)).toEqual(catAfter);
          expect(joinedCategories(catBefore, true)).toEqual(catAfterDist);

        }

        const tests = () => {
          testRepeatArr();
          testJoinedCategories();
          console.log("tests completed")
        }
        tests();
  //------------------------------------------------------------------------//
  //------------------------------------------------------------------------//
  //------------------------------------------------------------------------//
        //REACT

      class Welcome extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            typepeople: "People"
          }
        }
        changeHandler(e) {
          let newName = e.target.value;
          updateCanva({type_people: newName});
          this.setState({
            typepeople: newName
          })
        }
        render() {
          return (
            <div>
              Welcome To You Poll Creator!
              <input
                type="name"
                ref="generalname"
                value={this.state.typepeople}
                onChange={this.changeHandler.bind(this)}
              />
            </div>
          );
        }
      }
      class DefineGroup extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            number: 10,
            skincolor: {
              light: 50,
              dark: 50
            },
            namegroup: "Politicians",
            sex: {
              male: 50,
              female: 50
            },
            hairrange: {
              blonde: 25,
              brown: 25,
              gray: 25,
              red: 25
            }
          }
        }
        changeHandler(e) {
          e.preventDefault();
          let self = this;
          this.setState({
            number: self.refs.number.value,
            namegroup: self.refs.namegroup.value,
          });
        }
        drawHandler(e) {
            e.preventDefault();
            draw({
                number: this.state.number,
                skincolor: this.state.skincolor,
                namegroup: this.state.namegroup,
                sex: this.state.sex,
                hairrange: this.state.hairrange
            });
        }
        erasePrevious(e){
          e.preventDefault();
          groups.pop();
          draw();
        }
        /*checkboxHandler(color) {
          let valColor = this.state.hairs[color],
              newState = this.state.hairs;
          newState[color] = !valColor;
          this.setState({
            hairs: newState
          });
        }*/
        hairRangeHandler(e) {
          let self = this,
              color = e.target.name,
              prevVal = self.state.hairrange[color],
              actualVal = Number(e.target.value),
              letiation = actualVal - prevVal,
              sumValOtherColors = Object.keys(self.state.hairrange)
                                  .reduce((tot, col) => {
                                    if(col !== color) {
                                      tot += self.state.hairrange[col];
                                    }
                                    return tot;
                                  }, 0),
             newHairRange = Object.keys(self.state.hairrange)
                            .reduce((obj, col) => {
                              if(col === color) {
                                obj[col] = actualVal;
                              } else {
                                let valCol = self.state.hairrange[col];
                                obj[col] =  valCol - valCol
                                            * letiation / sumValOtherColors;
                              }
                              return obj;
                            }, {});

              this.setState({
                hairrange: newHairRange
              })
        }
        sexRangeHandler(e) {
          let sexChanged = e.target.name,
              val = Number(e.target.value);

          if(sexChanged === "male") {
            let valMale = val,
                valFemale = 100 - val;
          } else {
            let valMale = 100 - val,
                valFemale = val
          }

          this.setState({
            sex: {
              male: valMale,
              female: valFemale
            }
          });
        }
        skincolorRangeHandler(e) {
          let skinChanged= e.target.name,
              val = Number(e.target.value);
          if(skinChanged === "light") {
            let lightVal = val,
                darkVal = 100 - val;
          } else {
            let lightVal = 100 - val,
                darkVal = val;
          }
          this.setState({
            skincolor: {
              light: lightVal,
              dark: darkVal
            }
          });
        }
        render () {
          return (
            <div>
              <button
                onClick={this.erasePrevious.bind(this)}
                className="btn btn-danger">
                  Erase Previous
              </button>
              <form>
                <label for="number">
                  Number of faces
                  <input
                        type="number"
                        ref="number"
                        value={this.state.number}
                        onChange={this.changeHandler.bind(this)}
                        placeholder="Ethiopians"
                  />
                </label>
                <br />
                <label for="namegroup">
                  Name of the group
                  <input
                        type="text"
                        ref="namegroup"
                        value={this.state.namegroup}
                        onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <br />
                <label for="sex">
                Sex<br />
                  Male
                  <input
                    type="range"
                    min={0}
                    max={100}
                    step={1}
                    ref="sex_male"
                    name="male"
                    value={this.state.sex.male}
                    onChange={this.sexRangeHandler.bind(this)}
                  />
                  <br />
                  Female
                  <input
                    type="range"
                    min={0}
                    max={100}
                    step={1}
                    ref="sex_female"
                    name="female"
                    value={this.state.sex.female}
                    onChange={this.sexRangeHandler.bind(this)}
                  />
                </label>
                <br />
                <label for="SkinColor">
                Skin Color<br />
                Light
                  <input
                    type="range"
                    name="light"
                    value={this.state.skincolor.light}
                    onChange={this.skincolorRangeHandler.bind(this)}
                  />
                Dark
                  <input
                    type="range"
                    name="dark"
                    value={this.state.skincolor.dark}
                    onChange={this.skincolorRangeHandler.bind(this)}
                  />
                </label>
                <br />
                <label for="HairColor">
                Hair Color
                  <br />
                  Blonde
                  <input
                    type="range"
                    max={100}
                    min={0}
                    ref="hair_blonde_ran"
                    name="blonde"
                    value={this.state.hairrange.blonde}
                    onChange={this.hairRangeHandler.bind(this)}
                  />
                  Brown
                  <input
                    type="range"
                    max={100}
                    min={0}
                    ref="hair_brown_ran"
                    name="brown"
                    value={this.state.hairrange.brown}
                    onChange={this.hairRangeHandler.bind(this)}
                  />
                  <br />
                  Gray
                  <input
                    type="range"
                    max={100}
                    min={0}
                    ref="hair_gray_ran"
                    name="gray"
                    value={this.state.hairrange.gray}
                    onChange={this.hairRangeHandler.bind(this)}
                  />
                  Red
                  <input
                    type="range"
                    max={100}
                    min={0}
                    ref="hair_red_ran"
                    name="red"
                    value={this.state.hairrange.red}
                    onChange={this.hairRangeHandler.bind(this)}
                  />


                </label>
                <br />
              <button className="btn btn-info"
                      onClick={this.drawHandler.bind(this)}>
                  Add Group!
              </button>
              </form>
            </div>
          );
        }
      }

      class DimensionsConfigurator extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            multitudesdistance: multitudes_distance,
            faceradius: face_radius,
            canvaswidth: canvas_width,
            canvasheight: canvas_height,
          }
        }
        changeHandler(e) {
          let self = this;
          let state = this.state;
          updateCanva({
            multitudes_distance: self.refs.multitudesdistance.value,
            face_radius: self.refs.faceradius.value,
            canvas_width: self.refs.canvaswidth.value,
            canvas_height: self.refs.canvasheight.value,
          });
          this.setState({
            multitudesdistance: self.refs.multitudesdistance.value,
            faceradius: self.refs.faceradius.value,
            canvaswidth: self.refs.canvaswidth.value,
            canvasheight: self.refs.canvasheight.value,
          });
        }

        render() {
          return (
            <div>
              <form>
                <label for="canvaswidth">
                  Canvas Width
                  <input
                    type="number"
                    step={5}
                    ref="canvaswidth"
                    value={this.state.canvaswidth}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <label for="canvasheight">
                  Canvas Height
                  <input
                    type="number"
                    step={5}
                    ref="canvasheight"
                    value={this.state.canvasheight}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <hr />
                <label for="faceradius">
                  Face radius<br />
                  <input
                    type="number"
                    ref="faceradius"
                    value={this.state.faceradius}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <label for="multitudesdistance">
                  Distance between groups<br />
                  <input
                    type="number"
                    ref="multitudesdistance"
                    value={this.state.multitudesdistance}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
              </form>
            </div>
          )
        }
      }
      class FontsConfigurator extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            topfont: top_font,
            topfontsize: top_font_size,
            multitudesfont: multitudes_font,
            multitudesfontsize: multitudes_font_size,
            topfontposy: top_font_pos_y
          }
        }
        changeHandler(e) {
          let self = this;
          let state = this.state;
          updateCanva({
            top_font_size:  self.refs.topfontsize.value,
            multitudes_font_size:  self.refs.multitudesfontsize.value,
            top_font: self.refs.topfont.value,
            multitudes_font: self.refs.multitudesfont.value,
            top_font_pos_y: self.refs.topfontposy.value
          });
          this.setState({
            topfontsize:  self.refs.topfontsize.value,
            topfont: self.refs.topfont.value,
            multitudesfontsize:  self.refs.multitudesfontsize.value,
            multitudesfont: self.refs.multitudesfont.value,
            topfontposy: self.refs.topfontposy.value
          });
        }

        render() {
          return (
            <div>
              <form>
                <label for="topfontsize">
                  Font size of the top text<br />
                  <input
                    type="number"
                    ref="topfontsize"
                    value={this.state.topfontsize}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <label for="topfont">
                  Font of the top text<br />
                  <select
                    ref="topfont"
                    value={this.state.topfont}
                    onChange={this.changeHandler.bind(this)}
                  >
                    <option value="roboto"> Roboto </option>
                    <option value="caveat"> Caveat </option>
                    <option value="arial"> Arial </option>
                    <option value="serif"> Serif </option>
                  </select>
                </label>
                <label for="topfontposy">
                  Vertical position of the top<br />
                  <input
                    type="number"
                    ref="topfontposy"
                    value={this.state.topfontposy}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <label for="multitudesfontsize">
                  Font size of text under each multitude<br />
                  <input
                    type="number"
                    ref="multitudesfontsize"
                    value={this.state.multitudesfontsize}
                    onChange={this.changeHandler.bind(this)}
                  />
                </label>
                <label for="multitudesfont">
                  Font of the multitudes text<br />
                  <select
                    ref="multitudesfont"
                    value={this.state.multitudesfont}
                    onChange={this.changeHandler.bind(this)}
                  >
                    <option value="roboto"> Roboto </option>
                    <option value="caveat"> Caveat </option>
                    <option value="arial"> Arial </option>
                    <option value="serif"> Serif </option>
                  </select>
                </label>
              </form>
            </div>
          )
        }
      }
      class Page extends React.Component {
        render() {
          switch (this.props.page) {
            case "welcome":
              return (
                <Welcome />
              );
              break;
            case "definegroup":
              return (
                <DefineGroup />
              );
              break;
            case "dimensionsconfigurator":
                return (
                  <DimensionsConfigurator />
                );
                break;
            case "fontsconfigurator":
              return (
                <FontsConfigurator />
              );
              break;
            default:
              return (
                <div> Hola Hola </div>
              );
          }
        }
      }
      class Pagination extends React.Component {
        render() {
          return (
            <div className="btn-group">
              <button className="btn btn-default"
                      onClick={this.props.changeNumPage.bind(this,-1)}
              > Prev </button>
              <button className="btn btn-default"
                      onClick={this.props.changeNumPage.bind(this,1)}
              >
                 Next </button>
            </div>
          );
        }
      }
      class Configurator extends React.Component {
        constructor(props) {
          super(props);
          this.state = {
            pageNum: 1,
            page: "definegroup"
          }
          this.pageNames = ["welcome",
                            "definegroup",
                            "dimensionsconfigurator",
                            "fontsconfigurator"
                          ];
        }
        changeNumPage(letiation) {
          let newPageNum = this.state.pageNum + letiation,
              pageName = this.pageNames[newPageNum];
          this.setState({
            pageNum: newPageNum,
            page: pageName
          })
        }
        render() {
          return(
            <div className="panel-body container-fixed">
              <div className="latCol col-xs-2 col-md-2">
                <button className="navBtn"
                        onClick={this.changeNumPage.bind(this, -1)}
                > P </button>
              </div>
              <div className="cenCol col-xs-8 col-md-8">
                <Page page={this.state.page} />
              </div>
              <div className="latCol col-xs-2 col-md-2">
                <button className="navBtn"
                        onClick={this.changeNumPage.bind(this, 1)}
                > N </button>
              </div>
              {/*<Pagination
                  changeNumPage={this.changeNumPage.bind(this)}

              />*/}
            </div>
          );
        }
      }
      ReactDOM.render(
        <Configurator />,
      document.getElementById("configurator-app"));
    </script>
  </body>
</html>
